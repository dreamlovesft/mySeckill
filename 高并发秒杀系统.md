# 高并发秒杀系统

## 前端->MD5加密->后端->MD5加密->数据库

![image-20210713192700413](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210713192700413.png)

## 参数校验的封装，使用spring-boot-starter-validation

将相关代码逻辑封装在注解里

### 1.@Valid LoginController里面

![image-20210714110740611](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714110740611.png)

### 2.跳转到 LoginVo

- 验证非空 @NotNull
- 验证长度 @Length(32)

```java
@Data
public class LoginVo {
    @NotNull
    @IsMobile
    private String mobile;
    
    @NotNull
    @Length(min=32)
    private String password;
}

```

### 通过注解实现手机格式的校验

@IsMobile

创建自定义注解，放在validator包下

![image-20210714111952963](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714111952963.png)

```java
package com.song.validator;

import com.song.vo.IsMobileValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import javax.validation.constraints.NotNull;
import java.lang.annotation.*;

@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.TYPE_USE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(
        validatedBy = {IsMobileValidator.class}//填写定义规则类
)
/**
 * 验证手机格式
 */
public @interface IsMobile {


    boolean required() default true;//默认要求手机号必填

    String message() default "手机号码格式错误";//报错消息



    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};


}
```

封装定义规则到IsMobileValidator类

```java
package com.song.vo;

import com.song.utils.ValidatorUtil;
import com.song.validator.IsMobile;
import org.springframework.util.StringUtils;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

/**
 * @program: seckill-demo
 * @description: 手机校验规则
 * @author: Songfangteng
 * @create: 2021-07-14 11:27
 **/
public class IsMobileValidator implements ConstraintValidator<IsMobile,String> {

    //获取默认值是必填还是非必填
    private boolean required = false;
    @Override
    public void initialize(IsMobile constraintAnnotation) {
        required = constraintAnnotation.required();//获取注解中required我们写入的布尔值
    }

    @Override
    public boolean isValid(String s, ConstraintValidatorContext constraintValidatorContext) {
        //如果是必填选项
        if(required){
            return ValidatorUtil.isMobile(s);
        }else{//如果是非必填选项
            if(StringUtils.isEmpty(s)){//非必填项为空，返回true
                return true;
            }else{
                return ValidatorUtil.isMobile(s);
            }
        }
    }
}
```

通过上述三个注解等效实现了原来的参数校验功能

```
//参数校验
        if(StringUtils.isEmpty(mobile) || StringUtils.isEmpty(password)){
            return RespBean.error(RespBeanEnum.LOGIN_ERROR);
        }
        if(!ValidatorUtil.isMobile(mobile)){
            return RespBean.error(RespBeanEnum.MOBILE_ERROR);
        }
```

## 异常的处理

通常一个web程序在运行过程中，由于用户的操作不当，或者程序的bug，有大量需要处理的异常。其中有些异常是需要暴露给用户的，比如登陆超时，权限不足等等。可以通过弹出提示信息的方式告诉用户出了什么错误。

而这就表示在程序中需要一个机制，去处理这些异常，将程序的异常转换为用户可读的异常。而且最重要的，是要将这个机制统一，提供统一的异常处理。因为我设计这个结构的主要目的是为了简化代码。

在探寻spring的异常处理机制的时候，我分别使用了三种方式。三种方式都是使用的@ExceptionHandler注解。
 当一个Controller中有方法加了@ExceptionHandler之后，这个Controller其他方法中没有捕获的异常就会以参数的形式传入加了@ExceptionHandler注解的那个方法中。

注解的方式，使用@RestControllerAdvice+ @ExceptionHandler 注解实现全局处理，使用异常处理类将异常处理模块解耦出来

```java
package com.song.exception;

import com.song.vo.RespBean;
import com.song.vo.RespBeanEnum;
import org.springframework.validation.BindException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;



/**
 * @program: seckill-demo
 * @description: 全局异常处理类
 * @author: Songfangteng
 * @create: 2021-07-14 16:29
 **/
@RestControllerAdvice//返回responseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(Exception.class)

    public RespBean ExceptionHandler(Exception e){
        if(e instanceof GlobalException){
            GlobalException ex = (GlobalException) e;
            return RespBean.error(ex.getRespBeanEnum());
        }else if(e instanceof BindException){
            BindException ex = (BindException) e;
            RespBean respBean = RespBean.error(RespBeanEnum.BIND_ERROR);
            respBean.setMessage("参数校验异常"+ex.getBindingResult().getAllErrors().get(0).getDefaultMessage());//get(0)获取第一个错误
            return respBean;
        }

        return RespBean.error(RespBeanEnum.ERROR);
    }
}
```

## 完善登录功能

分布式session工具类，判断当前用户是否登录，将用户信息保存到session中

cookie工具类

```java
package com.song.utils;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.net.URLEncoder;
/**
 * @program: seckill-demo
 * @description: cookile工具类
 * @author: Songfangteng
 * @create: 2021-07-14 17:21
 **/
public final class CookieUtil {

    /**
     * 得到Cookie的值, 不编码
     *
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName) {
        return getCookieValue(request, cookieName, false);
    }

    /**
     * 得到Cookie的值,
     *
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, boolean isDecoder) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i < cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    if (isDecoder) {
                        retValue = URLDecoder.decode(cookieList[i].getValue(), "UTF-8");
                    } else {
                        retValue = cookieList[i].getValue();
                    }
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 得到Cookie的值,
     *
     * @param request
     * @param cookieName
     * @return
     */
    public static String getCookieValue(HttpServletRequest request, String cookieName, String encodeString) {
        Cookie[] cookieList = request.getCookies();
        if (cookieList == null || cookieName == null) {
            return null;
        }
        String retValue = null;
        try {
            for (int i = 0; i < cookieList.length; i++) {
                if (cookieList[i].getName().equals(cookieName)) {
                    retValue = URLDecoder.decode(cookieList[i].getValue(), encodeString);
                    break;
                }
            }
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return retValue;
    }

    /**
     * 设置Cookie的值 不设置生效时间默认浏览器关闭即失效,也不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue) {
        setCookie(request, response, cookieName, cookieValue, -1);
    }

    /**
     * 设置Cookie的值 在指定时间内生效,但不编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage) {
        setCookie(request, response, cookieName, cookieValue, cookieMaxage, false);
    }

    /**
     * 设置Cookie的值 不设置生效时间,但编码
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, boolean isEncode) {
        setCookie(request, response, cookieName, cookieValue, -1, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage, boolean isEncode) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, isEncode);
    }

    /**
     * 设置Cookie的值 在指定时间内生效, 编码参数(指定编码)
     */
    public static void setCookie(HttpServletRequest request, HttpServletResponse response, String cookieName,
                                 String cookieValue, int cookieMaxage, String encodeString) {
        doSetCookie(request, response, cookieName, cookieValue, cookieMaxage, encodeString);
    }

    /**
     * 删除Cookie带cookie域名
     */
    public static void deleteCookie(HttpServletRequest request, HttpServletResponse response,
                                    String cookieName) {
        doSetCookie(request, response, cookieName, "", -1, false);
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     *
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
                                          String cookieName, String cookieValue, int cookieMaxage, boolean isEncode) {
        try {
            if (cookieValue == null) {
                cookieValue = "";
            } else if (isEncode) {
                cookieValue = URLEncoder.encode(cookieValue, "utf-8");
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage > 0)
                cookie.setMaxAge(cookieMaxage);
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!"localhost".equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath("/");
            response.addCookie(cookie);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 设置Cookie的值，并使其在指定时间内生效
     *
     * @param cookieMaxage cookie生效的最大秒数
     */
    private static final void doSetCookie(HttpServletRequest request, HttpServletResponse response,
                                          String cookieName, String cookieValue, int cookieMaxage, String encodeString) {
        try {
            if (cookieValue == null) {
                cookieValue = "";
            } else {
                cookieValue = URLEncoder.encode(cookieValue, encodeString);
            }
            Cookie cookie = new Cookie(cookieName, cookieValue);
            if (cookieMaxage > 0) {
                cookie.setMaxAge(cookieMaxage);
            }
            if (null != request) {// 设置域名的cookie
                String domainName = getDomainName(request);
                System.out.println(domainName);
                if (!"localhost".equals(domainName)) {
                    cookie.setDomain(domainName);
                }
            }
            cookie.setPath("/");
            response.addCookie(cookie);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 得到cookie的域名
     */
    private static final String getDomainName(HttpServletRequest request) {
        String domainName = null;
        // 通过request对象获取访问的url地址
        String serverName = request.getRequestURL().toString();
        if (serverName == null || serverName.equals("")) {
            domainName = "";
        } else {
            // 将url地下转换为小写
            serverName = serverName.toLowerCase();
            // 如果url地址是以http://开头  将http://截取
            if (serverName.startsWith("http://")) {
                serverName = serverName.substring(7);
            }
            int end = serverName.length();
            // 判断url地址是否包含"/"
            if (serverName.contains("/")) {
                //得到第一个"/"出现的位置
                end = serverName.indexOf("/");
            }

            // 截取
            serverName = serverName.substring(0, end);
            // 根据"."进行分割
            final String[] domains = serverName.split("\\.");
            int len = domains.length;
            if (len > 3) {
                // www.xxx.com.cn
                domainName = domains[len - 3] + "." + domains[len - 2] + "." + domains[len - 1];
            } else if (len <= 3 && len > 1) {
                // xxx.com or xxx.cn
                domainName = domains[len - 2] + "." + domains[len - 1];
            } else {
                domainName = serverName;
            }
        }

        if (domainName != null && domainName.indexOf(":") > 0) {
            String[] ary = domainName.split("\\:");
            domainName = ary[0];
        }
        return domainName;
    }
}
```



UUID工具类

```java
package com.song.utils;

import java.util.UUID;

/**
 * @program: seckill-demo
 * @description: UUIDUtil工具类
 * @author: Songfangteng
 * @create: 2021-07-14 17:24
 **/
public class UUIDUtil {
    public static String uuid() {
        return UUID.randomUUID().toString().replace("-", "");
    }
}

```



在cookie中将登录用户利用UUID保存成相关信息

```java
判断当前用户是否登录
         */
        //生成cookie
        String ticket = UUIDUtil.uuid();
        //将cookie和用户对象存到放在session里
        request.getSession().setAttribute(ticket,user);//key:ticket value:user
        CookieUtil.setCookie(request, response, "userTicket", ticket);
        return RespBean.success();
    }
```

## 分布式session问题

![image-20210714225313526](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714225313526.png)

多台tomcat一起提供服务，导致tomcat之间session信息共享的问题

![image-20210714205317356](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714205317356.png)

cookie是明文的存在风险

![image-20210714205443134](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714205443134.png)

## Redis

后台服务式启动：redis-server.exe --service-install redis.windows.conf --loglevel verbose

卸载可以使用 redis-server --service-uninstall



 ( 安装redis服务 )输入：redis-server.exe --service-install redis.windows.conf --loglevel verbose

输入：redis-server.exe redis.windows.conf( 启动服务 )

输入：redis-server --service-stop （停止服务）
![image-20210714215442554](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714215442554.png)

数据结构（Redis_key, Redis_value[Hash_key, Hash_value]

Redis的相关语法

## 实现分布式的session

### 第一种方案：通过springSession

将用户信息存到session中，然后从不同的地方获取session

依赖

```
<!--spring data redis -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <!--commons-pool2 对象池依赖 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-pool2</artifactId>
        </dependency>
        <!--springSession依赖 -->
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
```

yml配置

```
  #redis配置
  redis:
    #服务器地址
    host: 127.0.0.1
    #端口
    port: 6379
    #数据库
    database: 1
    #超时时间
    connect-timeout: 10000ms
    #连接池
    lettuce:
      pool:
        #最大连接数
        max-active: 8
        #最大阻塞等待时间
        max-wait: 10000ms
        #最大空闲连接
        max-idle: 200
        #最小空闲连接
        min-idle: 5
```

### 第二种方法

将用户信息提取出来，保存到同一个redis，而不是session

redis配置

```java
@Configuration
public class RedisConfig {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory reconnectionFactory){
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();

        //key序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        //value序列化
        redisTemplate.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        //Hash key序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        //Hash value序列化
        redisTemplate.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());

        //注入连接工厂
        redisTemplate.setConnectionFactory(reconnectionFactory);
        return redisTemplate;
    }
}
```

#### 根据cookie获取用户

接口

```java
/**
     * 根据cookie获取用户
     * @param userTicket
     * @return
     */
    User getUserByCookie(String userTicket, HttpServletRequest request, HttpServletResponse response);
```

接口的实现类,重写方法

```java
@Override
    public User getUserByCookie(String userTicket, HttpServletRequest request, HttpServletResponse response) {
        if (StringUtils.isEmpty(userTicket)) {
            return null;
        }
        User user = (User)redisTemplate.opsForValue().get("user" + userTicket);
        if (user != null){
            CookieUtil.setCookie(request, response, "userTicket", userTicket);
        }
        return user;
    }
```

Controller层

```java
public class GoodsController {
    @Autowired
    private IUserService userService;
    /**
     * 跳转到商品列表页
     * @param request
     * @param model
     * @param tickets
     * @return
     */
    @RequestMapping("/toList")
    public String toList(HttpServletRequest request, HttpServletResponse response,
                         Model model, @CookieValue("userTicket") String tickets){//@CookieValue("userTicket")拿到cookie的值
        //cookie为空返回到登录页面
        if(StringUtils.isEmpty(tickets)){
            return "login";
        }
        //User user = (User) session.getAttribute(tickets);
        User user = userService.getUserByCookie(tickets, request, response);
        if(user == null){//当前用户不存在
            return "login";
        }
        model.addAttribute("user", user);//将user信息传到前端
        return "goodsList";
    }
}

```

结果显示用户信息保存在redis中

![image-20210714225152853](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714225152853.png)

redis启动

![image-20210714225227720](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714225227720.png)

## **优化登录**

### 背景

每一个接口响应前(对应用户跳转到同一页面)都必须判断用户是否登录，即通过获取是否存在对应的ticket，根据ticket进一步去redis判断ticket对应的用户是否存在。然后再决定是否去执行接口的方法

方法：

将下述代码封装解耦

```java
//cookie为空返回到登录页面
        if(StringUtils.isEmpty(tickets)){
            return "login";
        }
        //User user = (User) session.getAttribute(tickets);
        User user = userService.getUserByCookie(tickets, request, response);
        if(user == null){//当前用户不存在
            return "login";
        }
```

![image-20210714230134438](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210714230134438.png)

编写MVC配置类

1.WebConfig

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.List;

/**
 * @program: seckill-demo
 * @description: MVC配置类
 * @author: Songfangteng
 * @create: 2021-07-15 09:20
 **/
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {

    @Autowired
    private UserArgumentResolver userArgumentResolver;

    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
        resolvers.add(userArgumentResolver);
    }
}
```

2.UserArgumentResolver

```java
import com.song.pojo.User;
import com.song.service.IUserService;
import com.song.utils.CookieUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.MethodParameter;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * @program: seckill-demo
 * @description: 用户自定义参数
 * @author: Songfangteng
 * @create: 2021-07-15 09:21
 **/
@Component//注入，WebConfig要使用
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    @Autowired
    private IUserService userService;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        Class<?> clazz = parameter.getParameterType();
        return clazz == User.class;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {

        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);
        //根据cookie的那么获取对应的cookie
        String ticket = CookieUtil.getCookieValue(request, "userTicket");
        System.out.println(ticket);
        if(StringUtils.isEmpty(ticket)){
            return null;
        }
        return userService.getUserByCookie(ticket, request,response);
    }
}
```

修改GoodsController

```java
@RequestMapping("/toList")
public String toList(Model model, User user){//@CookieValue("userTicket")拿到cookie的值

    ////cookie为空返回到登录页面
    //if(StringUtils.isEmpty(tickets)){
    //    return "login";
    //}
    ////User user = (User) session.getAttribute(tickets);
    //userService.getUserByCookie(tickets, request, response)
    //if(user == null){//当前用户不存在
    //    return "login";
    //}
    model.addAttribute("user", user);//将user信息传到前端
    model.addAttribute("goodsList",goodsService.findGoodVo());
    return "goodsList";
}
```

## 回顾登录功能的实现

1.最简单的登录功能：controller - service - mapper - 数据库

参数校验麻烦- 利用Validation组件解决

结果只能在后端抛异常，不能再前端展示，登录错误相关的提示信息

全局异常处理优化

2.分布式session问题的解决

- springSession 将用户信息存储到session，不同的服务端可用访问这一个session
- redis 将新湖信息存储到redis中

3.每一个接口都需要对用户的登录状态进行校验问题

通过自定义参数类，将判断ticket是否为空，ticket对应用户是否存在的功能解耦出来 

```
@Configuration
@EnableWebMvc
```

## 总体大纲展示

有利于总结

![image-20210715104506208](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210715104506208.png)

### 数据库查询路线：

1.Controller层，GoodsController文件

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {
    @Autowired
    private IUserService userService;
    @Autowired
    private IGoodsService goodsService;
    /**
     * 跳转到商品列表页
     //* @param request
     * @param model
     //* @param tickets
     * @return
     */
    @RequestMapping("/toList")
    public String toList(Model model, User user){//@CookieValue("userTicket")拿到cookie的值

        model.addAttribute("user", user);//将user信息传到前端
        model.addAttribute("goodsList",goodsService.findGoodVo());
        return "goodsList";
    }
}

```

2.service层下

接口类IGoodsService声明findGoodVo()方法

```java
/**
 * <p>
 *  服务类
 * </p>
 *
 * @author songfangteng
 * @since 2021-07-16
 */
public interface IGoodsService extends IService<Goods> {
    /**
     * 获取商品列表
     * @return
     */
    List<GoodsVo> findGoodVo();
}
```

3.service.impl层下

接口实现类里实现 findGoodVo()方法

```java
/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author songfangteng
 * @since 2021-07-16
 */
@Service
public class GoodsServiceImpl extends ServiceImpl<GoodsMapper, Goods> implements IGoodsService {
    //数据库查询
    @Autowired
    private GoodsMapper goodsMapper;
    /**
     * 获取商品列表
     * @return
     */
    @Override
    public List<GoodsVo> findGoodVo() {
        return goodsMapper.findGoodVo();
    }
}
```

4.mapper层下

mapper里的接口类实现与数据库交互

```java
/**
 * <p>
 *  服务实现类
 * </p>
 *
 * @author songfangteng
 * @since 2021-07-16
 */
@Service
public class GoodsServiceImpl extends ServiceImpl<GoodsMapper, Goods> implements IGoodsService {
    //数据库查询
    @Autowired
    private GoodsMapper goodsMapper;
    /**
     * 获取商品列表
     * @return
     */
    @Override
    public List<GoodsVo> findGoodVo() {
        return goodsMapper.findGoodVo();
    }
}
```

5.resource/mapper

在resource/mapper下mapper接口对应的xml文件下执行sql语句

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.song.mapper.GoodsMapper">

    <!-- 通用查询映射结果 -->
    <resultMap id="BaseResultMap" type="com.song.pojo.Goods">
        <id column="id" property="id" />
        <result column="goods_name" property="goodsName" />
        <result column="goods_title" property="goodsTitle" />
        <result column="goods_img" property="goodsImg" />
        <result column="goods_detail" property="goodsDetail" />
        <result column="goods_price" property="goodsPrice" />
        <result column="goods_stock" property="goodsStock" />
    </resultMap>

    <!-- 通用查询结果列 -->
    <sql id="Base_Column_List">
        id, goods_name, goods_title, goods_img, goods_detail, goods_price, goods_stock
    </sql>
    
    <!-- 获取商品列表 -->
    <select id="findGoodsVo" resultType="com.song.vo.GoodsVo">
        select g.id,g.goods_name,g.goods_title,g.goods_img,g.goods_detail,g.goods_price,g.goods_stock,
               sg.seckill_price,sg.stock_count,sg.start_date,sg.end_date
        from
             seckill.t_goods g left join seckill.t_seckill_goods as sg on g.id=sg.goods_id
    </select>

</mapper>
```

### 将从数据库拿到的数据通过前端展示

主要利用import org.springframework.ui.Model;中的Model.addAttribute()方法

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {
    @Autowired
    private IUserService userService;
    @Autowired
    private IGoodsService goodsService;
    /**
     * 跳转到商品列表页
     //* @param request
     * @param model
     //* @param tickets
     * @return
     */
    @RequestMapping("/toList")
    public String toList(Model model, User user){//@CookieValue("userTicket")拿到cookie的值
        model.addAttribute("user", user);//将user信息传到前端
        model.addAttribute("goodsList",goodsService.findGoodVo());
        return "goodsList";
    }
}
```

前端通过thymeleaf模板引擎接收

![image-20210716195353005](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716195353005.png)

报错：

![image-20210716201541680](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716201541680.png)

原因：在配置文件中，静态资源默认为/**

![image-20210716203205295](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716203205295.png)

但是配置文件和配置类共存的情况下，配置类Webconfig的优先级更高，优先加载，spring就去该配置类找，原理我们没有配置静态资源

在配置类Webconfig添加

```java
private static final String[] CLASSPATH_RESOURCE_LOCATIONS = {
        "classpath:/META-INF/resources/", "classpath:/resources/",
        "classpath:/static/", "classpath:/public/" };

@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    registry.addResourceHandler("/**")
            .addResourceLocations(CLASSPATH_RESOURCE_LOCATIONS);
}
```

![image-20210716202623741](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716202623741.png)



然后测试发现报500错误

![image-20210716205608784](C:/Users/songfangteng521/AppData/Roaming/Typora/typora-user-images/image-20210716205608784.png)

后台警告：

![image-20210716205538434](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716205538434.png)

redis里TTL为-1，用户的 key 不存在

排错：

注释掉

```java
// model.addAttribute("goodsList",goodsService.findGoodVo());
```

发现可以成功登录

定位到问题就是出现在 model.addAttribute("goodsList",goodsService.findGoodVo());上，结合obj==null ，xml文件连接到数据库可能出现问题

id 和方法名不对应

![image-20210716222211278](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716222211278.png)

![image-20210716222338086](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716222338086.png)

修改xml文件id = "findGoodVo"

![image-20210716223801256](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210716223801256.png)

商品详情页的实现

**相关问题**：复制来的html文件，可能从前端接受的thymeleaf关键字会爆红，这是IDEA造成的，可以直接运行

### 前端商品详情页

controller层 GoodsController类里添加

```java
/**
     * 跳转商品详情页
     * @param goodsID
     * @return
     */
    @RequestMapping("/toDetail/{goodsID}")
    public String toDetail(Model model, User user, @PathVariable Long goodsID){
        model.addAttribute("user",user);
        model.addAttribute("goods",goodsService.findGoodVoByGoodsId(goodsID));
        return "goodsDetail";
    }
```



```html
<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>商品详情</title>
    <!-- jquery -->
    <script type="text/javascript" th:src="@{/js/jquery.min.js}"></script>
    <!-- bootstrap -->
    <link rel="stylesheet" type="text/css" th:href="@{/bootstrap/css/bootstrap.min.css}"/>
    <script type="text/javascript" th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
    <!-- layer -->
    <script type="text/javascript" th:src="@{/layer/layer.js}"></script>
    <!-- common.js -->
    <script type="text/javascript" th:src="@{/js/common.js}"></script>
</head>
<body>
<div class="panel panel-default">
    <div class="panel-heading">秒杀商品详情</div>
    <div class="panel-body">
        <span th:if="${user eq null}"> 您还没有登录，请登陆后再操作<br/></span>
        <span>没有收货地址的提示。。。</span>
    </div>
    <table class="table" id="goods">
        <tr>
            <td>商品名称</td>
            <td colspan="3" th:text="${goods.goodsName}"></td>
        </tr>
        <tr>
            <td>商品图片</td>
            <td colspan="3"><img th:src="@{${goods.goodsImg}}" width="200" height="200"/></td>
        </tr>
        <tr>
            <td>秒杀开始时间</td>
<!--            <td th:text="${#dates.format(goods.startDate,'yyyy-MM-dd HH:mm:ss')}"></td>-->
<!--            <td id="seckillTip">-->
<!--                <input type="hidden" id="remainSeconds" th:value="${remainSeconds}">-->
<!--                <span th:if="${secKillStatus eq 0}">秒杀倒计时: <span id="countDown" th:text="${remainSeconds}"></span>秒-->
<!--                </span>-->
<!--                <span th:if="${secKillStatus eq 1}">秒杀进行中</span>-->
<!--                <span th:if="${secKillStatus eq 2}">秒杀已结束</span>-->
<!--            </td>-->
<!--            <td>-->
<!--                <form id="secKillForm" method="post" action="/seckill/doSeckill">-->
<!--                    <input type="hidden" name="goodsId" th:value="${goods.id}">-->
<!--                    <button class="btn btn-primary btn-block" type="submit" id="buyButton">立即秒杀</button>-->
<!--                </form>-->
<!--            </td>-->
        </tr>
        <tr>
            <td>商品原价</td>
            <td colspan="3" th:text="${goods.goodsPrice}"></td>
        </tr>
        <tr>
            <td>秒杀价</td>
            <td colspan="3" th:text="${goods.seckillPrice}"></td>
        </tr>
        <tr>
            <td>库存数量</td>
            <td colspan="3" th:text="${goods.stockCount}"></td>
        </tr>
    </table>
</div>
</body>
<script>
    $(function () {
        countDown();
    });
    //
    // function countDown() {
    //     var remainSeconds = $("#remainSeconds").val();
    //     var timeout;
    //     //秒杀还未开始
    //     if (remainSeconds > 0) {
    //         $("#buyButton").attr("disabled", true);
    //         timeout = setTimeout(function () {
    //             $("#countDown").text(remainSeconds - 1);
    //             $("#remainSeconds").val(remainSeconds - 1);
    //             countDown();
    //         }, 1000);
    //         // 秒杀进行中
    //     } else if (remainSeconds == 0) {
    //         $("#buyButton").attr("disabled", false);
    //         if (timeout) {
    //             clearTimeout(timeout);
    //         }
    //         $("#seckillTip").html("秒杀进行中")
    //     } else {
    //         $("#buyButton").attr("disabled", true);
    //         $("#seckillTip").html("秒杀已经结束");
    //     }
    // };

</script>
</html>
```

### 前端时间格式化

将

```html
<td th:text="${goods.startDate}"></td>
```

变为

```html
<td th:text="${#dates.format(goods.startDate,'yyyy-MM-dd HH:mm:ss')}"></td>
```

### 倒计时功能

前端

```
<td id="seckillTip"><!--秒杀状态标记位-->
                <span th:if="${seckillStatus eq 0}">秒杀倒计时: <span th:text="${remainSeconds}"></span>秒</span>
                <span th:if="${seckillStatus eq 1}">秒杀进行中</span>
                <span th:if="${seckillStatus eq 2}">秒杀已结束</span>
            </td>
```

后端

```java
public String toDetail(Model model, User user, @PathVariable Long goodsID){
        model.addAttribute("user",user);//根据user信息，判断用户是否登录
        GoodsVo goodVo = goodsService.findGoodVoByGoodsId(goodsID);
        Date startDate = goodVo.getStartDate();
        Date endDate = goodVo.getEndDate();
        Date nowDate = new Date();
        //秒杀状态标志位，默认为开始
        int seckillStatus = 0;
        //秒杀倒计时
        int remainSeconds = 0;

        if(nowDate.before(startDate)){
            remainSeconds = (int) (startDate.getTime() - nowDate.getTime()) / 1000;
        }else if(nowDate.after(endDate)){
            //秒杀已结束
            seckillStatus = 2;
            remainSeconds = -1;
        }else{
            //秒杀进行中
            seckillStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("seckillStatus",seckillStatus);
        model.addAttribute("remainSeconds",remainSeconds);
        model.addAttribute("goods", goodVo);
        return "goodsDetail";
    }
```

![image-20210717113802915](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210717113802915.png)

### 秒的动态实现

倒计时主动刷新，前端定时器实现

```html
td id="seckillTip"><!--秒杀状态标记位-->
                <input type="hidden" id="remainSeconds" th:value="${remainSeconds}">
                <span th:if="${seckillStatus eq 0}">秒杀倒计时: <span id="countDown"
                                                                 th:text="${remainSeconds}"></span>秒</span>
                <span th:if="${seckillStatus eq 1}">秒杀进行中</span>
                <span th:if="${seckillStatus eq 2}">秒杀已结束</span>
            </td>
```

![image-20210717144520677](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210717144520677.png)

定义countDown函数

```html
<script>
    $(function () {
        countDown();
    });

    function countDown() {
        var remainSeconds = $("#remainSeconds").val();
        var timeout;
        //秒杀未开始
        if(remainSeconds>0){
            timeout = setTimeout(function(){
                $("#countDown").text(remainSeconds-1);//网页呈现的文本值减一
                $("#remainSeconds").val(remainSeconds-1);
                countDown();
            },1000);
            //秒杀进行中
        }else if(remainSeconds==0){
            if(timeout){
                clearTimeout(timeout);//如果倒计时还存在，清空倒计时
            }
            $("#seckillTip").html("秒杀进行中")
        }else{
            $("#seckillTip").html("秒杀已结束！")
        }
    }
</script>
```

定义秒杀按钮

```html
<td>
                <form id="seckillForm" action="/seckill/doSeckill">
                    <input type="hidden" name="goodsId" th:value="${goods.id}"><!--商品id传入-->
                    <button class="btn btn-primary btn-block" type="submit" id="buyButton">立即秒杀</button><!--class样式-->
                </form>
            </td>
```

秒杀开始前和结束后，按钮置灰

![image-20210717150647494](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210717150647494.png)

### 秒杀详情页面

功能实现

```java
package com.song.controller;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.song.pojo.Order;
import com.song.pojo.SeckillOrder;
import com.song.pojo.User;
import com.song.service.IGoodsService;
import com.song.service.IOrderService;
import com.song.service.ISeckillOrderService;
import com.song.vo.GoodsVo;
import com.song.vo.RespBeanEnum;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

/**
 * @program: seckill-demo
 * @description: 秒杀
 * @author: Songfangteng
 * @create: 2021-07-17 15:13
 **/
@Controller
@RequestMapping("/secKill")
public class SecKillController {
    @Autowired
    private IGoodsService goodsService;
    @Autowired
    private ISeckillOrderService seckillOrderService;
    @Autowired
    private IOrderService orderService;

    @RequestMapping("/doSecKill")
    public String doSecKill(Model model, User user, Long goodsId){
        if(user == null){
            return "login";
        }
        model.addAttribute("user", user);
        GoodsVo goodsVo = goodsService.findGoodVoByGoodsId(goodsId);
        //判断商品库存
        if(goodsVo.getStockCount()<1){
            model.addAttribute("errmsg", RespBeanEnum.EMPTY_STOCK.getMessage());
            return "secKillFail";//跳到错误页面并给出报错信息
        }
        //判断是否重复抢购 mybatis-plus
        SeckillOrder seckillOrder = seckillOrderService.getOne(new QueryWrapper<SeckillOrder>().eq("user_id", user.getId())
                .eq("goods_id", goodsId));
        if(seckillOrder != null){
            //已抢过商品，秒杀失败
            model.addAttribute("errmsg", RespBeanEnum.REPEAT_ERROR.getMessage());
            return "secKillFail";
        }
        Order order = orderService.seckill(user, goodsVo);
        model.addAttribute("order",order);
        model.addAttribute("goodsVo",goodsVo);
        return "orderDetail";
    }

}
```

orderService.seckill(user, goodsVo)功能在OrderServiceImpl里的实现，

```java
@Service
public class OrderServiceImpl extends ServiceImpl<OrderMapper, Order> implements IOrderService {
    @Autowired
    private ISeckillGoodsService seckillGoodsService;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private ISeckillOrderService seckillOrderService;
    /**
     * 秒杀
     * @param user
     * @param goodsVo
     * @return
     */

    @Override
    public Order seckill(User user, GoodsVo goodsVo) {
        //查询数据库里的保存的库存信息
        SeckillGoods seckillGoods = seckillGoodsService.getOne(new QueryWrapper<SeckillGoods>()
                .eq("goods_id", goodsVo.getId()));
        /**
         * 生成订单
         */
        //库存减一
        seckillGoods.setStockCount(seckillGoods.getStockCount()-1);
        seckillGoodsService.updateById(seckillGoods);

        Order order = new Order();
        order.setUserId(user.getId());
        order.setGoodsId(goodsVo.getId());
        order.setDeliveryAddrId(0L);
        order.setGoodsName(goodsVo.getGoodsName());
        order.setGoodsCount(0);
        order.setGoodsPrice(new BigDecimal("0"));
        order.setOrderChannel(1);
        order.setStatus(0);//创建未支付
        order.setCreateDate(new Date());
        //order.setPayDate(new Date());
        orderMapper.insert(order);

        //生成秒杀订单
        SeckillOrder seckillOrder = new SeckillOrder();
        seckillOrder.setUserId(user.getId());
        seckillOrder.setOrderId(order.getId());
        seckillOrder.setGoodsId(goodsVo.getId());

        seckillOrderService.save(seckillOrder);

        return order;
    }
}
```



报错

![image-20210717162219819](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210717162219819.png)

排查：thymeleaf没有成功配置

![image-20210717163120445](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210717163120445.png)

## 秒杀功能总结

表：商品表，秒杀商品表，订单表，秒杀订单表

## docker

docker的整个生命周期有三部分组成：镜像（image）+容器（container）+仓库（repository）

docker 容器=镜像+可读层，容器是由镜像实例化而来。

```text
docker run -it ubuntu
```

### 创建

`docker create`:创建容器，处于停止状态

### 查看

- `docker ps`: 查看当前运行的容器

- `docker ps -a`:查看所有容器，包括停止的

- 标题含义：

  CONTAINER ID:容器的唯一表示ID。
  IMAGE:创建容器时使用的镜像。
  COMMAND:容器最后运行的命令。
  CREATED:创建容器的时间。
  STATUS:容器状态。
  PORTS:对外开放的端口。
  NAMES:容器名。可以和容器ID一样唯一标识容器，同一台宿主机上不允许有同名容器存在，否则会冲突。
  ![image-20210718110753207](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718110753207.png)

### 启动

容器名：docker start docker_run，或者ID：docker start 43e3fef2266c。
–restart(自动重启)：默认情况下容器是不重启的，–restart标志会检查容器的退出码来决定容器是否重启容器。
docker run --restart=always --name docker_restart -d centos /bin/sh -c "while true;do echo hello world; sleep;done":
--restart=always:不管容器的返回码是什么，都会重启容器。
--restart=on-failure:5:当容器的返回值是非0时才会重启容器。5是可选的重启次数。

### 终止

- `docker stop [NAME]/[CONTAINER ID]`:将容器退出。
- `docker kill [NAME]/[CONTAINER ID]`:强制停止一个容器。

### 删除

`docker rm [NAME]/[CONTAINER ID]`:不能够删除一个正在运行的容器，会报错。需要先停止容器。

### Centos

#### 执行以下命令装载容器：

```
docker run -itd -p 50022:22 --privileged --name myCentos centos:7 /usr/sbin/init
docker run -itd -p 50022:22 -p 33010:3306 --privileged --name mySqlCentos centos-sql:8 /usr/sbin/init
docker run -itd -p 33060:3306 --privileged --name mySqlCentos centos-sql:8 /usr/sbin/init

docker run -it -p 33060:3306 --name sqlcentos centos-sql:8  /bin/bash
```

参数解析：

- -d ——后台运行容器并返回容器ID
- -i ——交互模式运行容器，通常与 -t 同时使用
- -t ——为容器重新分配一个伪输入终端，通常与 -i 同时使用
- –name ——为容器指定一个名称，此例为容器指定名为centos7
- –privileged： 可以使container内的root拥有真正的root权限
  -d： 后台运行容器，并返回容器ID；
  -i： 以交互模式运行容器，通常与 -t 同时使用；
  -p： 指定端口映射，格式为：主机(宿主)端口:容器端口
  -t： 为容器重新分配一个伪输入终端，通常与 -i 同时使用


*注：这里必须加上/bin/bash，让容器后执行`/bin/bash`命令，否则容器将无法使用bash命令。*

#### 连接（开启）容器

```
#开启
docker start c9c64ccd91e5
# 连接容器，参数为容器ID。
docker attach c9c64ccd91e5

方法2
docker exec -it myCentos /bin/bash
docker exec -it mySqlCentos /bin/bash
```

```
# 查看CentOS系统信息
cat /etc/os-release
```

![image-20210718111943635](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718111943635.png)

至此，CentOS7的系统已经跑起来了，要退出只需在终端键入exit回车。如果要停止容器，在终端执行`docker container stop 容器ID`即可；运行为`docker container start 容器ID`；要移除容器则执行`docker container rm 容器ID`。

### 容器中安装jdk

```
yum search java|grep jdk
```

![image-20210718112354665](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718112354665.png)

安装JDK

```
yum install -y java-1.8.0-openjdk
```

![image-20210718113207000](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718113207000.png)

查看Java版本

```
java -version
```

![image-20210718113307052](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718113307052.png)

#### 安装sshd

```
// 安装网络工具，可以使用ifconfig查看网卡ip信息
yum -y install net-tools
// 安装ssh服务
yum -y install openssh-server
// 需要的话，安装ssh客户端
yum -y install openssh-clients
// 需要的话，安装passwd，修改root用户密码，这里就不细说了
yum -y install passwd
```

#### 将myCentos制作成镜像

```
docker commit myCentos centos-jdk:8
```

#### 启动ssh服务

要进入到myCentos环境

```
systemctl start sshd
```

#### 使用Xshell连接

```
docker inspect d2f3c0267e5e | grep IPAddress
```

192.168.99.100是咱们docker宿主机的ip，启动docker时映射的端口号是50022，所以需要使用这个端口连接ssh服务，点击连接按钮后再弹出的窗口输入你之前设置的密码，即可完成连接。

修改用户密码 ：123456

```
echo 123456 |passwd --stdin root
```

用户登录名：root, password :

连接成功

![image-20210718163605391](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718163605391.png)

centos中启动MySQL

```
systemctl start mysqld
```

d表示守护进程

查看启动状态

```
systemctl status mysqld
```

![image-20210718170430111](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718170430111.png)

ctrl+c 退出 找回密码

```
grep "password" /var/log/mysqld.log
```

![image-20210718170859013](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718170859013.png)

ctrl+insert 复制 密码

shift+insert粘贴 密码

![image-20210718171141495](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718171141495.png)

输入密码

```
mysql -u root -p
```

![image-20210718171753346](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718171753346.png)

密码输入是不显示的

修改密码为rootRoot123.

```
ALTER USER 'root'@'localhost' identified by 'rootRoot123.';
flush privileges;
```

修改密码为1234

```
ALTER USER 'root'@'localhost' IDENTIFIED BY '1234';
flush privileges;
```

遇到问题：密码重置不生效

修改密码策略

```
set global validate_password.policy=0;
set global validate_password.length=4;

#展示密码制定策略
show variables like 'validate_password%';
```

#原因：MySQL8.0开始将授权和创建用户分开了，分开执行即可

创建新用户并设置密码

```
create user 'seckill'@'%' identified by '123456';
```

授权

```
grant all privileges on *.* to 'seckill'@'%';
flush privileges;
```

查看虚拟机主机IP

```
ifconfig -a
```

发现没有ens33条目

重启网络服务，执行

```
systemctl stop NetworkManager                             临时关闭
systemctl disable NetworkManager                          永久关闭网络管理命令
systemctl start network.service                           开启网络服务

```

报错

![image-20210718215247006](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718215247006.png)

```
#安装polkit
yum -y install polkit
#查看polkit是否启动
systemctl status polkit
```

还是报错

![image-20210718215247006](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718215247006.png)

经百度，执行https://blog.csdn.net/junshi66/article/details/104177961

```lua
getent group polkitd >/dev/null && echo -e "\e[1;32mpolkitd group already exists\e[0m" || { groupadd -r polkitd && echo -e "\e[1;33mAdded missing polkitd group\e[0m" || echo -e "\e[1;31mAdding polkitd group FAILED\e[0m"; }
getent passwd polkitd >/dev/null && echo -e "\e[1;32mpolkitd user already exists\e[0m" || { useradd -r -g polkitd -d / -s /sbin/nologin -c "User for polkitd" polkitd && echo -e "\e[1;33mAdded missing polkitd user\e[0m" || echo -e "\e[1;31mAdding polkitd user FAILED\e[0m"; }

```

```lua
rpm -Va polkit\* && echo -e "\e[1;32mpolkit* rpm verification passed\e[0m" || { echo -e "\e[1;33mResetting polkit* rpm user/group ownership & perms\e[0m"; rpm --setugids polkit polkit-pkla-compat; rpm --setperms polkit polkit-pkla-compat; }

```

```
#关闭容器并重启
shutdown -r now

docker start c8a
docker exec -it myCentos /bin/bash


```

查看polkit状态

```
systemctl status polkit
```

![image-20210718215911243](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718215911243.png)

再次执行

```
systemctl stop NetworkManager                             临时关闭
systemctl disable NetworkManager                          永久关闭网络管理命令
systemctl start network.service                           开启网络服务
```

systemctl start network.service 报错!

![](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210718220143076.png)

执行

```
systemctl restart NetworkManager.service
```

正确的排错思路：https://cloud.tencent.com/developer/article/1744792

#### 通过端口来接Docker中的CentOS容器MySQL数据库

==CentOS的3306端口没有开放,不允许远程连接,要把CentOS的3306端口绑定到宿主机空闲的端口，通过访问宿主机空闲端口，来访问CentOS的3306端口==



查看端口占用

```
netstat -ano|findstr "33060"
#杀死占用端口
tasklist|findstr "15984"
docker inspect --format "{{ .NetworkSettings.IPAddress }}" 47664fc919a6
```

```
SELECT DISTINCT CONCAT('User: ''',user,'''@''',host,''';') AS query FROM mysql.user;
查看某个用户的权限
show grants for 'test'@'%'; 
查看当前用户
select user();
删除用户
drop user 'seckill'@'%';
```

```
ALTER USER 'seckill'@'%' IDENTIFIED WITH mysql_native_password BY '1234';
```

![image-20210719112700321](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719112700321.png)

![image-20210719112808013](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719112808013.png)

## 新建centos里面数据库

可以将本地的seckill数据库导出为sql文件，然后在Linux执行导出的sql文件

![image-20210719144054854](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719144054854.png)

由于Linux里MySQL，root用户的密码是1234，所以要将properties文件里的密码对应更改。

![image-20210719144344603](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719144344603.png)

![image-20210719144435650](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719144435650.png)

本地MySQL数据库密码也要对应修改

![image-20210719161649969](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719161649969.png)

将springboot项目打包，上传到Linux

打包：

![image-20210719144835361](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719144835361.png)

成功

![image-20210719144950162](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719144950162.png)

找到生成的jar包（30多M）

![image-20210719145042192](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719145042192.png)

通过Xshell上传

![image-20210719145549728](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719145549728.png)

![image-20210719145656195](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719145656195.png)

前台运行测试

```
java -jar seckill-demo-0.0.1-SNAPSHOT.jar
```

![image-20210719145910026](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719145910026.png)

去网页登录

![image-20210719151139044](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719151139044.png)

失败没有开放8080端口，还是这个问题

![image-20210719151219585](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719151219585.png)

只开放了2个端口，难受

### 修改要端口映射的容器

网上说可以用 修改要端口映射的容器的配置文件 方法https://www.huaweicloud.com/articles/2f77258d9743af7269285e1bf10ef58e.html.但这是Linux下的方法

```
iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.2:8000
添加端口转发
netsh interface portproxy add v4tov4 listenport=80 connectaddress=127.0.0.1 connectport=8080
netsh interface portproxy add v4tov4 listenaddress=localhost listenport=8081 connectaddress=172.17.0.2 connectport=8080
netsh interface portproxy add v4tov4 listenaddress=localhost listenport=8081（外网） connectaddress=172.17.0.2 connectport=8080（内网）
一般开发在内网完成
删除端口转发
netsh interface portproxy del v4tov4 listenport=80 listenaddress=127.0.0.1
查看已经配置了哪些端口转发
netsh interface portproxy show  v4tov4
```

![image-20210719154949840](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719154949840.png)

可以随时根据需要添加或删除端口转发条目，并且重启操作系统仍能自动保存之前的配置并自动启用，

这样我们将centos （IP：172.17.0.2）的8080端口通过转发个localhost的8081端口暴露出来。然后访问localhost:8081/login/toLogin，发现成功连接

![image-20210719155329676](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719155329676.png)

登录报服务端异常

尝试安装redis

```
查看版本
yum search redis
yum install -y redis

yum -y install redis-3.0.7-4.el6.art.x86_64.rpm
```

启动新安装的redis：

```csharp
[root@21yunwei src]# /etc/init.d/redis  start
#设置redis自启动
chkconfig  redis on
```

![image-20210719172849296](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719172849296.png)

成功登入

![image-20210719173033780](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210719173033780.png)

## 不同用户秒杀

### 配置不同用户

使用工具类生成用户

```java
package com.song.utils;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.song.pojo.User;
import com.song.vo.RespBean;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

/**
 * @program: seckill-demo
 * @description: 用户生成工具类
 * @author: Songfangteng
 * @create: 2021-07-20 10:58
 **/
public class UserUtil {
    private static void createUser(int count) throws Exception {
        List<User> users = new ArrayList<>(count);
        //生成用户
        for (int i = 0; i < count; i++) {
            User user = new User();
            user.setId(13000000000L + i);
            user.setLoginCount(1);
            user.setNickname("user" + i);
            user.setRegisterDate(new Date());
            user.setSlat("1a2b3c4d");
            user.setPassword(MD5Utils.inputPassToDBPass("123456", user.getSlat()));
            users.add(user);
        }
        System.out.println("create user");
        // 插入数据库
        Connection conn = getConn();
        String sql = "insert into seckill.t_user(login_count, nickname, register_date, slat, password, id)values(?,?,?,?,?,?)";
        PreparedStatement pstmt = conn.prepareStatement(sql);
        for (int i = 0; i < users.size(); i++) {
            User user = users.get(i);
            pstmt.setInt(1, user.getLoginCount());
            pstmt.setString(2, user.getNickname());
            pstmt.setTimestamp(3, new Timestamp(user.getRegisterDate().getTime()));
            pstmt.setString(4, user.getSlat());
            pstmt.setString(5, user.getPassword());
            pstmt.setLong(6, user.getId());
            pstmt.addBatch();
        }
        pstmt.executeBatch();
        pstmt.close();
        conn.close();
        System.out.println("insert to db");
        //登录，生成userTicket
        String urlString = "http://localhost:8080/login/doLogin";
        File file = new File("C:\\Users\\songfangteng521\\Desktop\\config.txt");
        if (file.exists()) {
            file.delete();
        }
        RandomAccessFile raf = new RandomAccessFile(file, "rw");
        file.createNewFile();
        raf.seek(0);
        for (int i = 0; i < users.size(); i++) {
            User user = users.get(i);
            URL url = new URL(urlString);
            HttpURLConnection co = (HttpURLConnection) url.openConnection();
            co.setRequestMethod("POST");
            co.setDoOutput(true);
            OutputStream out = co.getOutputStream();
            String params = "mobile=" + user.getId() + "&password=" + MD5Utils.inputPassToFromPass("123456");
            out.write(params.getBytes());
            out.flush();
            InputStream inputStream = co.getInputStream();
            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            byte buff[] = new byte[1024];
            int len = 0;
            while ((len = inputStream.read(buff)) >= 0) {
                bout.write(buff, 0, len);
            }
            inputStream.close();
            bout.close();
            String response = new String(bout.toByteArray());
            ObjectMapper mapper = new ObjectMapper();
            RespBean respBean = mapper.readValue(response, RespBean.class);
            String userTicket = ((String) respBean.getObj());
            System.out.println("create userTicket : " + user.getId());

            String row = user.getId() + "," + userTicket;
            raf.seek(raf.length());
            raf.write(row.getBytes());
            raf.write("\r\n".getBytes());
            System.out.println("write to file : " + user.getId());
        }
        raf.close();

        System.out.println("over");
    }

    private static Connection getConn() throws Exception {
        String url = "jdbc:mysql://localhost:3306/seckill?useUnicode=true&characterEncoding=UTF-8&serverTimezone=Asia/Shanghai";
        String username = "root";
        String password = "1234";
        String driver = "com.mysql.cj.jdbc.Driver";
        Class.forName(driver);
        return DriverManager.getConnection(url, username, password);
    }

    public static void main(String[] args) throws Exception {
        createUser(5000);
    }
}
```



### 压测配置

HTTP默认请求值

![image-20210720153642152](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720153642152.png)

csv数据文件设置

![image-20210720153813527](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720153813527.png)

Http cookie 管理器

![image-20210720153902690](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720153902690.png)

HTTP请求：秒杀

![image-20210720153952137](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720153952137.png)

## 页面缓存

缓存一般适用于频繁被读取，变更比较少，数据量比较小，适用于并发场景，加快读取速度

不再进行跳转页面，而是返回页面，并且把页面缓存到redis中，以商品列表页作为例子（goodsList）

```java
@Controller
@RequestMapping("/goods")
public class GoodsController {
    @Autowired
    private IUserService userService;
    @Autowired
    private IGoodsService goodsService;
    @Autowired
    private RedisTemplate redisTemplate;
    @Autowired
    private ThymeleafViewResolver thymeleafViewResolver;
    /**
     * 跳转到商品列表页
     //* @param request
     * @param model
     //* @param tickets
     * @return
     */
    @RequestMapping(value="/toList",produces="text/html;charset=utf-8")
    @ResponseBody//返回对象
    public String toList(Model model, User user,
                         HttpServletRequest request, HttpServletResponse response){//@CookieValue("userTicket")拿到cookie的值
        //redis 中获取页面，不为空直接返回页面
        ValueOperations valueOperations = redisTemplate.opsForValue();
        String html = (String) valueOperations.get("goodsList");
        //判断页面是否存在
        if(!StringUtils.isEmpty(html)){
            return html;
        }
        model.addAttribute("user", user);//将user信息传到前端
        model.addAttribute("goodsList",goodsService.findGoodVo());

        //如果为空，收到渲染页面并保存到redis，返回
        WebContext webContext = new WebContext(request, response,request.getServletContext(), request.getLocale(),
                model.asMap());//model.asMap()model转map
        html = thymeleafViewResolver.getTemplateEngine().process("goodsList", webContext);
        if(!StringUtils.isEmpty(html)){//渲染成功，保存
            System.out.println("渲染成功");
            valueOperations.set("goodsList", html, 60, TimeUnit.MINUTES);
        }
        //return "goodsList";
        return html;
    }
```

从redis读取缓存，假如页面存在，返回给浏览器；如果不存在，手动渲染模板并保存在redis



渲染成功

![image-20210720164815415](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720164815415.png)

### URL缓存

/toDetail/{goodsID}，将goodsID对应的详情页面，保存到redis

```java
@RequestMapping(value="/toDetail/{goodsID}", produces="text/html;charset=utf-8")
    @ResponseBody
    public String toDetail(Model model, User user, @PathVariable Long goodsID,
                           HttpServletRequest request, HttpServletResponse response){

        ValueOperations valueOperations = redisTemplate.opsForValue();
        String html = ((String) valueOperations.get("goodsDetail:" + goodsID));//goodsDetail要和templates下HTML的文件名一致
        if(!StringUtils.isEmpty(html)){
            return html;
        }

        model.addAttribute("user",user);//根据user信息，判断用户是否登录
        GoodsVo goodVo = goodsService.findGoodVoByGoodsId(goodsID);
        Date startDate = goodVo.getStartDate();
        Date endDate = goodVo.getEndDate();
        Date nowDate = new Date();
        //秒杀状态标志位，默认为开始
        int seckillStatus = 0;
        //秒杀倒计时，秒为单位
        int remainSeconds = 0;

        if(nowDate.before(startDate)){
            remainSeconds = (int) (startDate.getTime() - nowDate.getTime()) / 1000;
        }else if(nowDate.after(endDate)){
            //秒杀已结束
            seckillStatus = 2;
            remainSeconds = -1;
        }else{
            //秒杀进行中
            seckillStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("seckillStatus",seckillStatus);
        model.addAttribute("remainSeconds",remainSeconds);
        model.addAttribute("goods", goodVo);

        //手动渲染
        WebContext webContext = new WebContext(request, response, request.getServletContext(),
                request.getLocale(), model.asMap());

        html  = thymeleafViewResolver.getTemplateEngine().process("goodsDetail", webContext);
        if(!StringUtils.isEmpty(html)){
            valueOperations.set("goodsDetail:"+goodsID, html, 60, TimeUnit.SECONDS);
        }
        //return "goodsDetail";
        return html;
    }
```



![image-20210720172500872](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720172500872.png)

![image-20210720172523129](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210720172523129.png)

渲染的页面要和模板一致

我们从后端要传输整个页面，传输量比较大

对象缓存 

通过ticket获取user对象

问题：用户的信息永久存储在redis，如果某个时刻，用户的信息做了变更怎么办，如何处理对应的redis信息

登录时将用户信息存入到redis，变更后清空redis里的信息，并让用户重新登陆，

service

```java
 /**
     * 更新用户密码
     * @param userTicket
     * @param password
     * @param request
     * @param response
     * @return
     */
    RespBean updatePassword(String userTicket, String password, HttpServletRequest request, HttpServletResponse response);
```

serviceImpl

```java
/**
     * 更新密码
     * @param userTicket
     * @param password
     * @param request
     * @param response
     * @return
     */
    @Override
    public RespBean updatePassword(String userTicket, String password, HttpServletRequest request, HttpServletResponse response) {
        User user = getUserByCookie(userTicket, request, response);
        if(user == null){
            throw new GlobalException(RespBeanEnum.MOBILE_NOT_EXIST);
        }
        user.setPassword(MD5Utils.inputPassToDBPass(password, user.getSlat()));
        int result = userMapper.updateById(user);
        if(result == 1){
            //删除Redis
            redisTemplate.delete("user"+userTicket);
            return RespBean.success();
        }
        return RespBean.error(RespBeanEnum.PASSSWROD_UPDATE_FAIL);
    }
```

继续进行压测实验，发现QPS有了提升，这是使用redis缓存的结果，现在渲染出来的，发送的仍然是整个页面，这个数据量还是比较大的

增加QPS的方式：使用页面缓存+页面详情的静态化

将页面的通用结果静态化，每次只加载详情页面的特异性数据

比如

![image-20210721103822112](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210721103822112.png)

这些数据不用每次都上传，本方案没有使用vue前端框架，而是使用Ajax模拟页面

set一个类的实例的快捷键：![image-20210721105616341](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210721105616341.png)alt+insert

### Ajax页面静态化

是一个问题

## 库存超卖



判断商品库存是否大于0， 更新库存的时候

```java
seckillGoodsService.update(new UpdateWrapper<SeckillGoods>().set("stock_count",
                seckillGoods.getStockCount()).eq("id", seckillGoods.getId()).gt("stock_count",
                0));

```

### 一个用户同时购买多件商品

将用户ID和商品ID绑定为一个索引，防止一个用户多次抢购，购买一次对应一个索引，再次执行相同购买请求时，该请求的被索引拦截

![image-20210722094210572](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722094210572.png)

QPS有了提升，将判断重复抢购的信息存入到redis

## 优化方向

1。redis缓存，页面静态化，商品详情，秒杀，订单的静态化，给数据库加唯一索引防止用户重复购买，更新商品库存前判断库存数量防止超卖.

2.接口优化

尽量减少接口与数据库的交互，redis预减库存

下单进入到队列缓冲，然后异步执行，增强数据库，mycat分表

## rabbitMq

安装erl

```
curl -s https://packagecloud.io/install/repositories/rabbitmq/erlang/script.rpm.sh | sudo bash
yum install -y erlang
```

![image-20210722111323911](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722111323911.png)

![image-20210722111611291](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722111611291.png)

**CentOS7：**
https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.8.5/rabbitmq-server-3.8.5-1.el7.noarch.rpm

```
yum -y install rabbitmq-server-3.8.5-1.el7.noarch.rpm
```

安装控制台

```
[root@f17e30d22989 ~]# rabbitmq-plugins list
rabbitmq-plugins enable rabbitmq_management
```

启动rabbitMQ

```
systemctl start rabbitmq-server.service
#查看启动状态
systemctl status rabbitmq-server.service
```

### 端口转发

15672端口转发到15673（用来访问可视化rabbitmq管理页面），5672端口转发到5673(用来连接消息队列)

```
netsh interface portproxy add v4tov4 listenaddress=localhost listenport=15673 connectaddress=172.17.0.2 connectport=15672
netsh interface portproxy add v4tov4 listenaddress=localhost listenport=5673 connectaddress=172.17.0.2 connectport=5672

netsh interface portproxy del v4tov4 listenport=5672 listenaddress=localhost
查看已经配置了哪些端口转发
netsh interface portproxy show  v4tov4
```

有博客说主机名要和IP地址做映射，我瞬间想起来了，主机名要确实要和ip地址做映射，这一步要在配IP的时候设置的。
root@后面的就是主机名，我这里主机名是promote，填你自己地主机名。

> ```
> vi /etc/hosts
> ```
>
> 把本机ip和主机名绑定一下即可
> 按i进入编辑模式，加一行
>
> 127.0.0.1	f17e30d22989
>
![image-20210722142519355](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722142519355.png)

f17e30d22989 相等于我的centos虚拟机的主机名

按ESC回到普通模式然后
:wq保存

最后service network restart 重启一下网络服务解决问题。

```
netstat -an|grep 15672
#查看占用端口进程的PID
netstat -tunlp|grep {port}
kill -9 {PID}
```

相关端口占用情况，是正常的

![image-20210722151059999](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722151059999.png)

```
ss -tnlp |grep 5672
```

http://localhost:15673/

![image-20210722152101648](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722152101648.png)

停止rabbitmq

```
systemctl stop rabbitmq-server.service
```

重新安装

https://blog.csdn.net/weixin_40584261/article/details/106826044

配置

```
cd /etc/rabbitmq/

vi rabbitmq.config

```

![image-20210722164435336](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722164435336.png)

虽然查看rabbitmq的状态始终都是激活中（ Active: activating (start)），但网页能进去

firewalld的基本使用

```
启动： systemctl start firewalld

查看状态： systemctl status firewalld

停止： systemctl disable firewalld

禁用： systemctl stop firewalld

开放端口
firewall-cmd --zone=public --add-port=15672/tcp --permanent
firewall-cmd --zone=public --add-port=5672/tcp --permanent
```

### springboot集成rabbitmq

依赖

```
<!--AMPQ依赖，rabbitmq实现了它 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>
```

![image-20210722170751772](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722170751772.png)

配置类, 准备一个队列

```java
import org.springframework.context.annotation.Bean;
import org.springframework.amqp.core.Queue;
import org.springframework.context.annotation.Configuration;


/**
 * @program: seckill-demo
 * @description: RabbitMQ配置类
 * @author: Songfangteng
 * @create: 2021-07-22 17:06
 **/
@Configuration

public class RabbitMQConfig {
    @Bean
    public Queue queue(){
        return new Queue("queue", true);
    }
}

```

声明消息发送者和接收者

MQSender

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

/**
 * @program: seckill-demo
 * @description: 消息发送者
 * @author: Songfangteng
 * @create: 2021-07-22 17:15
 **/
@Service
@Slf4j
public class MQSender {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    public void send(Object msg){
        log.info("发送消息："+ msg);
        rabbitTemplate.convertAndSend("queue", msg);
    }
}
```

MQReceiver

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Service;

/**
 * @program: seckill-demo
 * @description: 消息消费者
 * @author: Songfangteng
 * @create: 2021-07-22 17:26
 **/

@Service
@Slf4j
public class MQReceiver {
    @RabbitListener(queues = "queue")
    public void receive(Object msg){
        log.info("接收消息" + msg);
    }
}
```

报错BlockingQueueConsumer$DeclarationException: Failed to declare queue(s):[queue]

谷歌后，原来queue队列找不到，排查发现没有在@Configuration文件中配置该队列，添加注解@Configuration即可

![image-20210722182202856](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722182202856.png)

![image-20210722182050638](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722182050638.png)

### 队列机制

![image-20210722185459694](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722185459694.png)

#### fanout模式

广播模式，多个队列同时接受到同一个生产者的同一个消息，转发速度最快

配置类里 定义两个消息队列和一个交换机

```java
@Configuration
public class RabbitMQConfig {
    private static final String QUEUE01 = "queue_fanout01";
    private static final String QUEUE02 = "queue_fanout02";
    private static final String EXCHANGE = "fanoutExchange";
    @Bean
    public Queue queue(){
        return new Queue("queue", true);
    }
    @Bean
    public Queue queue01(){
        return new Queue(QUEUE01);
    }
    @Bean
    public Queue queue02(){
        return new Queue(QUEUE02);
    }
    @Bean
    public FanoutExchange fanoutExchange(){
        return new FanoutExchange(EXCHANGE);
    }

    //将队列绑定到交换机上
    @Bean
    public Binding binding01(){
        return BindingBuilder.bind(queue01()).to(fanoutExchange());
    }
    @Bean
    public Binding binding02(){
        return BindingBuilder.bind(queue02()).to(fanoutExchange());
    }


}
```

消息发送者MQReceiver

```java
@Service
@Slf4j
public class MQSender {
    @Autowired
    private RabbitTemplate rabbitTemplate;
    public void send(Object msg){
        log.info("发送消息："+ msg);
        rabbitTemplate.convertAndSend("fanoutExchange","", msg);
    }
}
```



消息接收者MQSender

```java
@Service
@Slf4j
public class MQReceiver {
    @RabbitListener(queues = "queue")
    public void receive(Object msg){
        log.info("接收消息" + msg);
    }

    @RabbitListener(queues="queue_fanout01")
    public void receive01(Object msg){
        log.info("QUEUE01接收消息："+msg);
    }
    @RabbitListener(queues="queue_fanout02")
    public void receive02(Object msg){
        log.info("接收消息：" + msg);
    }
}
```

消息发送实例

```java
@Controller
@RequestMapping("/user")
public class UserController {
    @Autowired
    private MQSender mQSender;

    /**
     * 测试用户信息
     */
    @RequestMapping("/info")
    @ResponseBody
    public RespBean info(User user){
        return RespBean.success();
    }

    /**
     * 测试发送RabbitMq消息
     */
    @RequestMapping("/mp")
    @ResponseBody
    public void mq(){
        mQSender.send("Hello");
    }
    
    /**
     * fanout模式
     */
    @RequestMapping("/mq/fanout")
    @ResponseBody
    public void mq01(){
        mQSender.send("Hello01");
    }
}
```



![](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722191215126.png)

queue01和queue02都接受到相同的消息：

![image-20210722195921254](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722195921254.png)

#### direct模式

通过路由键匹配不同的队列实现消息的接收，否则消息被抛弃

RabbitMQDirectConfig

```java
@Configuration
public class RabbitMQDirectConfig {
    private static final String QUEUE01 = "queue_direct01";
    private static final String QUEUE02 = "queue_direct02";
    private static final String EXCHANGE = "directExchange";
    private static final String ROUTINGKEY01 = "queue.red";
    private static final String ROUTINGKEY02 = "queue.green";

    @Bean
    public Queue queue01(){
        return new Queue(QUEUE01);
    }
    @Bean
    public Queue queue02(){
        return new Queue(QUEUE02);
    }
    @Bean
    public DirectExchange directExchange(){
        return new DirectExchange(EXCHANGE);
    }
    @Bean
    public Binding binding01(){
        return BindingBuilder.bind(queue01()).to(directExchange()).with(ROUTINGKEY01);
    }
    @Bean
    public Binding binding02(){
        return BindingBuilder.bind(queue02()).to(directExchange()).with(ROUTINGKEY02);
    }
}
```

MQSender

```java
@Service
@Slf4j
public class MQSender {
    @Autowired
    private RabbitTemplate rabbitTemplate;
     public void send01(Object msg){
        log.info("发送红色消息："+msg);
        rabbitTemplate.convertAndSend("directExchange","queue_red",msg);
    }

    public void send02(Object msg){
        log.info("发送绿色消息"+msg);
        rabbitTemplate.convertAndSend("directExchange", "queue_green", msg);
    }
}
```

![image-20210722210826563](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722210826563.png)

MQReceiver

```java
@Service
@Slf4j
public class MQReceiver {
    @RabbitListener(queues = "queue_direct02")
    public void receive03(Object msg){
        log.info("QUEUE01接收消息:"+msg);
    }
    @RabbitListener(queues = "queue_direct02")
    public void receive04(Object msg){
        log.info("QUEUE02接收xiaox:" + msg);
    }
}
```

UserController

```java
public class UserController {
    @Autowired
    private MQSender mQSender;
    /**
     *direct模式
     */
    @RequestMapping("/mq/direct01")
    public void  mq02(){
        mQSender.send01("Hello02");
    }
    @RequestMapping("/mq/direct02")
    public void mq03(){
        mQSender.send02("Hello03");
    }

}
```

![image-20210722210915332](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722210915332.png)

对应起来mqSender的方法；

请求1：http://localhost:8080/user/mq/direct01

![image-20210722211020552](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722211020552.png)

请求2：http://localhost:8080/user/mq/direct02

![image-20210722211128244](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722211128244.png)

#### toptic机制

#### Headers机制

## Redis预减库存

### 对数据库的访问次数复盘

存了俩个表，订单表和秒杀订单表，两次数据库操作，查询里一次库存（如下），总共对数据库三次操作

![image-20210722211748800](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722211748800.png)

判断是否重购的数据库操作被redis优化下来

```

```

![image-20210722212103048](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722212103048.png)

### 思路

1.系统初始化的时候将秒杀商品的初始量存入到redis,收到秒杀请求redis进行预减，最后当请求量变得很稀少的时候再通过异步对数据库进行操作.

2.将生成订单操作异步出去，前期大量请求过来可以迅速处理，后面消息队列再慢慢处理，体现了消息队列流量削峰功能

![image-20210722212610550](https://gitee.com/dreamlover521/typora-table/raw/master/image-20210722212610550.png)

异步出去后，返回排队中，因为不能保证订单成功或失败，入队的时候返回派对中，出队的时候对数据库进行真实操作

3.客户端做轮询，判断是否秒杀成功

#### 初始化系统时将商品的库存放到redis

#### 预减库存

```java
public class SecKillController implements InitializingBean {
	@Autowired
    private IGoodsService goodsService;
    @Autowired
    private ISeckillOrderService seckillOrderService;
    @Autowired
    private IOrderService orderService;
    @Autowired
    private RedisTemplate redisTemplate;

    @RequestMapping("/doSecKill")
    public RespBean doSecKill(Model model, User user, Long goodsId){
        if(user == null){
            return RespBean.error(RespBeanEnum.SESSION_ERROR);
        }
        ValueOperations valueOperations = redisTemplate.opsForValue();
        //判断是否重复抢购
        SeckillOrder seckillOrder =
                (SeckillOrder) redisTemplate.opsForValue().get("order:" + user.getId() + ":" + goodsId);
        if(seckillOrder != null){
            //已抢过商品，秒杀失败
            //model.addAttribute("errmsg", RespBeanEnum.REPEAT_ERROR.getMessage());
            return RespBean.error(RespBeanEnum.REPEAT_ERROR);
        }
        //递减，每调用一次自减1 stock:递减之后的库存
        Long stock = valueOperations.decrement("seckillGoods:" + goodsId);
        if(stock < 1){
            return RespBean.error(RespBeanEnum.EMPTY_STOCK);
        }
        orderService.seckill(user, goodsId);
        return null;
    }
    //初始化可以执行的方法，将库存预先加载到redis
    @Override
    public void afterPropertiesSet() throws Exception {
        List<GoodsVo> list = goodsService.findGoodVo();
        if(CollectionUtils.isEmpty(list)){
            return;
        }
        list.forEach(goodsVo -> {
            redisTemplate.opsForValue().set("seckillGoods:"+goodsVo.getId(), goodsVo.getStockCount());
        });
    }
}
```



#### 下单

```java
@Service
@Slf4j
public class MQReceiver {
    @Autowired
    private IGoodsService goodsService;
    @Autowired
    private RedisTemplate redisTemplate;
    @Autowired
    private IOrderService orderService;
    //消费任务
    @RabbitListener(queues="seckillQueue")
    public void receive(String message){
        log.info("Received Message:"+ message);
        //转回message对象
        SeckillMessage seckillMessage = JsonUtil.jsonString2Object(message, SeckillMessage.class);
        Long goodsId = seckillMessage.getGoodsId();
        User user = seckillMessage.getUser();

        GoodsVo goodsVo = goodsService.findGoodVoByGoodsId(goodsId);
        if(goodsVo.getStockCount() < 1){
            return;
        }
        //判断是否重复抢购
        SeckillOrder seckillOrder =
                (SeckillOrder) redisTemplate.opsForValue().get("order:" + user.getId() + ":" + goodsId);
        if(seckillOrder != null){
            //已抢过商品，秒杀失败
            //model.addAttribute("errmsg", RespBeanEnum.REPEAT_ERROR.getMessage());
            return;
        }
        //下单操作
        orderService.seckill(user, goodsVo);

    }
    }
```

预减库存,库存没了时，仍然接收大量请求与redis通信，也会增大负担。

#### 客户端轮询来真正判断客户端是否下单成功